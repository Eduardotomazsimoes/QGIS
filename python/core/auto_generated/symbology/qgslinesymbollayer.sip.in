/************************************************************************
 * This file has been generated automatically from                      *
 *                                                                      *
 * src/core/symbology/qgslinesymbollayer.h                              *
 *                                                                      *
 * Do not edit manually ! Edit header and run scripts/sipify.pl again   *
 ************************************************************************/






class QgsSimpleLineSymbolLayer : QgsLineSymbolLayer
{

%TypeHeaderCode
#include "qgslinesymbollayer.h"
%End
  public:
    QgsSimpleLineSymbolLayer( const QColor &color = DEFAULT_SIMPLELINE_COLOR,
                              double width = DEFAULT_SIMPLELINE_WIDTH,
                              Qt::PenStyle penStyle = DEFAULT_SIMPLELINE_PENSTYLE );


    static QgsSymbolLayer *create( const QgsStringMap &properties = QgsStringMap() ) /Factory/;
    static QgsSymbolLayer *createFromSld( QDomElement &element ) /Factory/;


    virtual QString layerType() const;


    virtual void startRender( QgsSymbolRenderContext &context );


    virtual void stopRender( QgsSymbolRenderContext &context );


    virtual void renderPolyline( const QPolygonF &points, QgsSymbolRenderContext &context );


    virtual void renderPolygonStroke( const QPolygonF &points, QList<QPolygonF> *rings, QgsSymbolRenderContext &context );


    virtual QgsStringMap properties() const;


    virtual QgsSimpleLineSymbolLayer *clone() const /Factory/;


    virtual void toSld( QDomDocument &doc, QDomElement &element, const QgsStringMap &props ) const;


    virtual QString ogrFeatureStyle( double mmScaleFactor, double mapUnitScaleFactor ) const;


    virtual void setOutputUnit( QgsUnitTypes::RenderUnit unit );

    virtual QgsUnitTypes::RenderUnit outputUnit() const;


    virtual void setMapUnitScale( const QgsMapUnitScale &scale );

    virtual QgsMapUnitScale mapUnitScale() const;


    virtual double estimateMaxBleed( const QgsRenderContext &context ) const;



    Qt::PenStyle penStyle() const;
    void setPenStyle( Qt::PenStyle style );

    Qt::PenJoinStyle penJoinStyle() const;
    void setPenJoinStyle( Qt::PenJoinStyle style );

    Qt::PenCapStyle penCapStyle() const;
    void setPenCapStyle( Qt::PenCapStyle style );

    bool useCustomDashPattern() const;
    void setUseCustomDashPattern( bool b );

    void setCustomDashPatternUnit( QgsUnitTypes::RenderUnit unit );
%Docstring
Sets the units for lengths used in the custom dash pattern.

:param unit: length units

.. seealso:: :py:func:`customDashPatternUnit`
%End

    QgsUnitTypes::RenderUnit customDashPatternUnit() const;
%Docstring
Returns the units for lengths used in the custom dash pattern.

.. seealso:: :py:func:`setCustomDashPatternUnit`
%End

    const QgsMapUnitScale &customDashPatternMapUnitScale() const;
    void setCustomDashPatternMapUnitScale( const QgsMapUnitScale &scale );

    QVector<qreal> customDashVector() const;
    void setCustomDashVector( const QVector<qreal> &vector );

    bool drawInsidePolygon() const;
%Docstring
Returns ``True`` if the line should only be drawn inside polygons, and any portion
of the line which falls outside the polygon should be clipped away.

This setting only has an effect when the line symbol is being
used to render polygon rings.

.. seealso:: :py:func:`setDrawInsidePolygon`
%End

    void setDrawInsidePolygon( bool drawInsidePolygon );
%Docstring
Sets whether the line should only be drawn inside polygons, and any portion
of the line which falls outside the polygon should be clipped away.

This setting only has an effect when the line symbol is being
used to render polygon rings.

.. seealso:: :py:func:`drawInsidePolygon`
%End

    virtual QVector<qreal> dxfCustomDashPattern( QgsUnitTypes::RenderUnit &unit ) const;

    virtual Qt::PenStyle dxfPenStyle() const;


    virtual double dxfWidth( const QgsDxfExport &e, QgsSymbolRenderContext &context ) const;

    virtual double dxfOffset( const QgsDxfExport &e, QgsSymbolRenderContext &context ) const;

    virtual QColor dxfColor( QgsSymbolRenderContext &context ) const;


  protected:




};



class QgsTemplatedLineSymbolLayerBase : QgsLineSymbolLayer
{
%Docstring

Base class for templated line symbols, e.g. line symbols which draw markers or hash
lines at intervals along the line feature.

.. versionadded:: 3.8
%End

%TypeHeaderCode
#include "qgslinesymbollayer.h"
%End
  public:

    enum Placement
    {
      Interval,
      Vertex,
      LastVertex,
      FirstVertex,
      CentralPoint,
      CurvePoint
    };

    QgsTemplatedLineSymbolLayerBase( bool rotateSymbol = true,
                                     double interval = 3 );

    bool rotateSymbols() const;
%Docstring
Returns ``True`` if the repeating symbols be rotated to match their line segment orientation.

.. seealso:: :py:func:`setRotateSymbols`
%End

    void setRotateSymbols( bool rotate );
%Docstring
Sets whether the repeating symbols should be rotated to match their line segment orientation.

.. seealso:: :py:func:`rotateSymbols`
%End

    double interval() const;
%Docstring
Returns the interval between individual symbols. Units are specified through intervalUnits().

.. seealso:: :py:func:`setInterval`

.. seealso:: :py:func:`intervalUnit`
%End

    void setInterval( double interval );
%Docstring
Sets the interval between individual symbols.

:param interval: interval size. Units are specified through setIntervalUnit()

.. seealso:: :py:func:`interval`

.. seealso:: :py:func:`setIntervalUnit`
%End

    void setIntervalUnit( QgsUnitTypes::RenderUnit unit );
%Docstring
Sets the units for the interval between symbols.

:param unit: interval units

.. seealso:: :py:func:`intervalUnit`

.. seealso:: :py:func:`setInterval`
%End

    QgsUnitTypes::RenderUnit intervalUnit() const;
%Docstring
Returns the units for the interval between symbols.

.. seealso:: :py:func:`setIntervalUnit`

.. seealso:: :py:func:`interval`
%End

    void setIntervalMapUnitScale( const QgsMapUnitScale &scale );
%Docstring
Sets the map unit ``scale`` for the interval between symbols.

.. seealso:: :py:func:`intervalMapUnitScale`

.. seealso:: :py:func:`setIntervalUnit`

.. seealso:: :py:func:`setInterval`
%End

    const QgsMapUnitScale &intervalMapUnitScale() const;
%Docstring
Returns the map unit scale for the interval between symbols.

.. seealso:: :py:func:`setIntervalMapUnitScale`

.. seealso:: :py:func:`intervalUnit`

.. seealso:: :py:func:`interval`
%End

    Placement placement() const;
%Docstring
Returns the placement of the symbols.

.. seealso:: :py:func:`setPlacement`
%End

    void setPlacement( Placement placement );
%Docstring
Sets the ``placement`` of the symbols.

.. seealso:: :py:func:`placement`
%End

    double offsetAlongLine() const;
%Docstring
Returns the offset along the line for the symbol placement. For Interval placements, this is the distance
between the start of the line and the first symbol. For FirstVertex and LastVertex placements, this is the
distance between the symbol and the start of the line or the end of the line respectively.
This setting has no effect for Vertex or CentralPoint placements.

:return: The offset along the line. The unit for the offset is retrievable via offsetAlongLineUnit.

.. seealso:: :py:func:`setOffsetAlongLine`

.. seealso:: :py:func:`offsetAlongLineUnit`

.. seealso:: :py:func:`placement`
%End

    void setOffsetAlongLine( double offsetAlongLine );
%Docstring
Sets the the offset along the line for the symbol placement. For Interval placements, this is the distance
between the start of the line and the first symbol. For FirstVertex and LastVertex placements, this is the
distance between the symbol and the start of the line or the end of the line respectively.
This setting has no effect for Vertex or CentralPoint placements.

:param offsetAlongLine: Distance to offset markers along the line. The offset
                        unit is set via setOffsetAlongLineUnit.

.. seealso:: :py:func:`offsetAlongLine`

.. seealso:: :py:func:`setOffsetAlongLineUnit`

.. seealso:: :py:func:`setPlacement`
%End

    QgsUnitTypes::RenderUnit offsetAlongLineUnit() const;
%Docstring
Returns the unit used for calculating the offset along line for symbols.

:return: Offset along line unit type.

.. seealso:: :py:func:`setOffsetAlongLineUnit`

.. seealso:: :py:func:`offsetAlongLine`
%End

    void setOffsetAlongLineUnit( QgsUnitTypes::RenderUnit unit );
%Docstring
Sets the unit used for calculating the offset along line for symbols.

:param unit: Offset along line unit type.

.. seealso:: :py:func:`offsetAlongLineUnit`

.. seealso:: :py:func:`setOffsetAlongLine`
%End

    const QgsMapUnitScale &offsetAlongLineMapUnitScale() const;
%Docstring
Returns the map unit scale used for calculating the offset in map units along line for symbols.

.. seealso:: :py:func:`setOffsetAlongLineMapUnitScale`
%End

    void setOffsetAlongLineMapUnitScale( const QgsMapUnitScale &scale );
%Docstring
Sets the map unit ``scale`` used for calculating the offset in map units along line for symbols.

.. seealso:: :py:func:`offsetAlongLineMapUnitScale`
%End


    virtual void renderPolyline( const QPolygonF &points, QgsSymbolRenderContext &context );

    virtual void renderPolygonStroke( const QPolygonF &points, QList<QPolygonF> *rings, QgsSymbolRenderContext &context );

    virtual QgsUnitTypes::RenderUnit outputUnit() const;

    virtual void setMapUnitScale( const QgsMapUnitScale &scale );

    virtual QgsMapUnitScale mapUnitScale() const;


  protected:

    virtual void setSymbolLineAngle( double angle ) = 0;
    virtual double symbolAngle() const = 0;
    virtual void setSymbolAngle( double angle ) = 0;
    virtual void renderSymbol( const QPointF &point, const QgsFeature *feature, QgsRenderContext &context, int layer = -1, bool selected = false ) = 0;

};

class QgsMarkerLineSymbolLayer : QgsTemplatedLineSymbolLayerBase
{

%TypeHeaderCode
#include "qgslinesymbollayer.h"
%End
  public:
    QgsMarkerLineSymbolLayer( bool rotateMarker = DEFAULT_MARKERLINE_ROTATE,
                              double interval = DEFAULT_MARKERLINE_INTERVAL );

    enum Placement
    {
      Interval,
      Vertex,
      LastVertex,
      FirstVertex,
      CentralPoint,
      CurvePoint
    };


    static QgsSymbolLayer *create( const QgsStringMap &properties = QgsStringMap() ) /Factory/;
%Docstring
Create a new MarkerLineSymbolLayerV2

:param properties: A property map to deserialize saved information from properties()

:return: A new MarkerLineSymbolLayerV2
%End

    static QgsSymbolLayer *createFromSld( QDomElement &element ) /Factory/;
%Docstring
Create a new MarkerLineSymbolLayerV2 from SLD

:param element: An SLD XML DOM element

:return: A new MarkerLineSymbolLayerV2
%End


    virtual QString layerType() const;

    virtual void startRender( QgsSymbolRenderContext &context );

    virtual void stopRender( QgsSymbolRenderContext &context );

    virtual QgsStringMap properties() const;

    virtual QgsMarkerLineSymbolLayer *clone() const /Factory/;

    virtual void toSld( QDomDocument &doc, QDomElement &element, const QgsStringMap &props ) const;

    virtual void setColor( const QColor &color );

    virtual QColor color() const;

    virtual QgsSymbol *subSymbol();

    virtual bool setSubSymbol( QgsSymbol *symbol /Transfer/ );

    virtual void setWidth( double width );

    virtual double width() const;

    virtual double width( const QgsRenderContext &context ) const;

    virtual double estimateMaxBleed( const QgsRenderContext &context ) const;

    virtual void setOutputUnit( QgsUnitTypes::RenderUnit unit );

    virtual QSet<QString> usedAttributes( const QgsRenderContext &context ) const;

    virtual bool hasDataDefinedProperties() const;

    virtual void setDataDefinedProperty( QgsSymbolLayer::Property key, const QgsProperty &property );


    bool rotateMarker() const;
%Docstring
Shall the marker be rotated.

:return: ``True`` if the marker should be rotated.
%End

    void setRotateMarker( bool rotate );
%Docstring
Shall the marker be rotated.
%End

  protected:


    virtual void setSymbolLineAngle( double angle );

    virtual double symbolAngle() const;

    virtual void setSymbolAngle( double angle );

    virtual void renderSymbol( const QPointF &point, const QgsFeature *feature, QgsRenderContext &context, int layer = -1, bool selected = false );


  private:
    QgsMarkerLineSymbolLayer( const QgsMarkerLineSymbolLayer &other );
};


class QgsHashedLineSymbolLayer : QgsTemplatedLineSymbolLayerBase
{
%Docstring

Line symbol layer type which draws repeating line sections along a line feature.

.. versionadded:: 3.8
%End

%TypeHeaderCode
#include "qgslinesymbollayer.h"
%End
  public:

    QgsHashedLineSymbolLayer( bool rotateSymbol = true,
                              double interval = 3 );

    static QgsSymbolLayer *create( const QgsStringMap &properties = QgsStringMap() ) /Factory/;
%Docstring
Create a new QgsHashedLineSymbolLayer

:param properties: A property map to deserialize saved information from properties()
%End


    virtual QString layerType() const;

    virtual void startRender( QgsSymbolRenderContext &context );

    virtual void stopRender( QgsSymbolRenderContext &context );

    virtual QgsStringMap properties() const;

    virtual QgsHashedLineSymbolLayer *clone() const /Factory/;

    virtual void setColor( const QColor &color );

    virtual QColor color() const;

    virtual QgsSymbol *subSymbol();

    virtual bool setSubSymbol( QgsSymbol *symbol /Transfer/ );

    virtual void setWidth( double width );

    virtual double width() const;

    virtual double width( const QgsRenderContext &context ) const;

    virtual double estimateMaxBleed( const QgsRenderContext &context ) const;

    virtual void setOutputUnit( QgsUnitTypes::RenderUnit unit );

    virtual QSet<QString> usedAttributes( const QgsRenderContext &context ) const;

    virtual bool hasDataDefinedProperties() const;

    virtual void setDataDefinedProperty( QgsSymbolLayer::Property key, const QgsProperty &property );


  protected:

    virtual void setSymbolLineAngle( double angle );

    virtual double symbolAngle() const;

    virtual void setSymbolAngle( double angle );

    virtual void renderSymbol( const QPointF &point, const QgsFeature *feature, QgsRenderContext &context, int layer = -1, bool selected = false );


  private:
    QgsHashedLineSymbolLayer( const QgsHashedLineSymbolLayer &other );
};



/************************************************************************
 * This file has been generated automatically from                      *
 *                                                                      *
 * src/core/symbology/qgslinesymbollayer.h                              *
 *                                                                      *
 * Do not edit manually ! Edit header and run scripts/sipify.pl again   *
 ************************************************************************/
